Platform : Elga (Veolia)
========================

This page last changed on Jan 04, 2011 by disidore.

Protocol overview
=================

ELGA is available in the VEOLIA Water purification system devices. ELGA
is a permanent flux of information concerning both contractual
parameters and measures.

Elga is compatible with two protocol type.

The first one is the "unsolicited response" protocol type. This protocol
is found on MEDICA PRO devices.

The second one is the "request response" protocol type. It is supported
by MEDICA RF devices. The request is made by sending a pulse on an
discrete output.

Elga: electrical characteristics
--------------------------------

The elga transmission is exploited through a RS232, with the following
properties:

For MEDICA PRO

-   Serial link configuration : 19200 bauds +/-1%, No parity, 8 data
    bits, 1 stop bit, No Flow control

For MEDICA RF

-   Serial link configuration : 1200 bauds +/-1%, No parity, 8 data
    bits, 1 stop bit, No Flow control
-   I/O Request pulse duration : 200ms < t < 600 ms

ELGA data model
---------------

The ELGA data model is based on a series of data having distinguishing
characteristics.

Primary tables

Object type

Type of

Comments

Integer \

32 bits \

Read-Only

- \

String \

Null terminated string \

Read-Only

- \

Protocol implementations
========================

OpenAT Implementation
---------------------

This asynchronous elga stack is initialized calling the
"ELGA\_InitContext(ElgaContext\* pElgaContext,...)". There are two way
of initializing the Elga driver. You can either use a callback function
or a LUA table to retrieve information.

when initializing the stack you have to set the line parameters (mainly,
parity, baudrate), the type of device (Medica Pro or Medica RF) from
which you want to acquire.

The stack is released by calling "ELGA\_ReleaseContext(ElgaContext\*
pElgaContext)".

Lua over OpenAT implementation
------------------------------

The stack can be initialized with default parameters, partially or
fully.

~~~~ {.theme: .Confluence; .brush: .java; .gutter: .false
style="font-size:12px;"}
Default value : "e,err=elga.new(nil, nil, Monitoring.vars.user, 'MEDICA_PRO')"
Partially :     "e,err=elga.new(nil, \{baudrate=19200\}, Monitoring.vars.user, 'MEDICA_PRO') "
Fully :         "e,err=elga.new('UART2', \{baudrate=19200, parity='none', data=8,stop=1, timeout=200\}, Monitoring.vars.user, 'MEDICA_PRO')"
~~~~

The last parameter is the type of device the BoxPro have to retrieve
data from. For now, it can be either 'MEDICA\_PRO' or 'MEDICA\_RF'.

If using a initialization via table, you will have access to read values
directly in your table.

If using a callback function, the read value will be passed as argument.

~~~~ {.theme: .Confluence; .brush: .java; .gutter: .false
style="font-size:12px;"}
Ex:
function func_print(toto)
print('time', toto.time)
end
~~~~

With "toto" being a table and "Time" being one of the value read from
device.

The stack is explicitely closed by calling "e:activate(false)". To
re-open it, "e:activate(true)" should be called. Calling "e:activate()"
will return the status of the stack, when '0' means idle, '1' means
enable and '2' means disable.

To release context as described in previous chapter, call "e:close()".

### Basic Lua implementation sample

~~~~ {.theme: .Confluence; .brush: .java; .gutter: .false
style="font-size:12px;"}
example 1 :

require 'elga'

pro,err=elga.new('UART2',{baudrate=19200,parity='none',data=8,stop=1,timeout=200},Monitoring.vars.user,'MEDICA_PRO')
p(err)

p(Monitoring.vars.user)


example 2:

require 'elga'

function view(elga_t)
print('time :', elga_t.time)
end

pro,err=elga.new('UART2',{baudrate=19200,parity='none',data=8,stop=1,timeout=200},view,'MEDICA_PRO')
~~~~

Document generated by Confluence on Mar 11, 2013 16:17
